import os
import shutil
import signal
import subprocess
import tempfile
import time
from .exceptions import *

# Only export the Simulator class
__all__ = ['Simulator']

class Simulator:
    """Launches a simulator instance.

    Example::

        import asyncio
        import agility
        import agility.messages as msgs

        async def main():
            # Connect to simulator on port 8080
            async with agility.JsonApi() as api:
                # Send messages, launch other tasks
                info = await api.query(msgs.GetRobotInfo())
                print(f"Robot name: {info.robot_name}")
            # When the 'async with' block exits, the connection shuts down

        # Launch simulator on port 8080
        with agility.Simulator("/path/to/ar-control") as sim:
            # asyncio.run(main()) # Python 3.7+ only
            asyncio.get_event_loop().run_until_complete(main()) # Python 3.6
        # When the 'with' block exits, the simulator shuts down

    Args:
        simulator_path: The relative or absolute path to the simulator binary.
        *args: All additional arguments should be strings that will be passed
               to the simulator as if they were command line arguments. These
               can be paths to TOML files, configuration mode names, or
               explicit TOML data.

    Keyword args:
        auto_port: Defaults to False, if True then the simulator is instructed
            to automatically select a port that doesn't conflict with other
            running simulators. The selected port is available in the port
            property of the returned simulator object. This option only works
            with versions of ar-control that support automatic port selection.

    The returned simulator object can be used as a context manager to
    automatically close the simulator when finished::

        with agility.Simulator('/path/to/ar-control') as sim:
            async with agility.JsonApi() as api:
                # Do things with API...

    Alternatively, :meth:`close` can be called to shut down the simulator when
    finished. When the simulator shuts down using either method, it checks to
    see if the simulator has already unexpectedly terminated and raises a
    :class:`.SimulatorTerminated` exception if so. This check can also be run
    at any other time while the simulator is running by calling :meth:`check`.

    """
    def __init__(self, simulator_path: str, *args, auto_port=False):

        # Appimages have a compatibility issue with docker (related to FUSE),
        # so explicitly extract the appimage to a temp folder first. The
        # --appimage-extract-and-run option was previously used here, but it
        # causes bigger problems with waiting for a clean shutdown.
        tempdir = tempfile.TemporaryDirectory()
        self._tempdir = tempdir # prevent tempdir being deleted early
        shutil.copy(simulator_path, tempdir.name + '/ar-control')
        subprocess.run(['./ar-control', '--appimage-extract'], cwd=tempdir.name,
                       stdout=subprocess.DEVNULL)
        app = tempdir.name + '/squashfs-root/bin/ar-control'

        # Launch the control process. Capture both stdout and stderr using
        # pipes, use unbuffered mode, and capture as bytes instead of as
        # decoded strings. After starting the program, convert the
        # stdout/stderr pipes to nonblocking mode. All of these settings are
        # necessary to successfully read lines from the control program as they
        # are output instead of only when the program terminates.
        if auto_port:
            args = ('server.port=0', *args)
        self._proc = subprocess.Popen([app, *args], stdout=subprocess.PIPE,
                                      stderr=subprocess.PIPE, bufsize=0)
        os.set_blocking(self._proc.stdout.fileno(), False)
        os.set_blocking(self._proc.stderr.fileno(), False)
        self._stdout = ''
        self._stderr = ''
        self._closed_normally = False

        # Check for immediate crashes
        self.check()

        # Get automatically assigned port if auto port assignment is enabled
        self._port = None
        if auto_port:
            # Read the port once the web thread starts
            start_time = time.time()
            while True:
                self.check()
                try:
                    path = '{}/ar-control/{}/port'.format(
                        os.getenv('XDG_RUNTIME_DIR', '/run'), self._proc.pid)
                    with open(path, 'r') as f:
                        self._port = int(f.read())
                    break
                except:
                    time.sleep(0.1)
                if time.time() - start_time > 5: # Give up after 5 seconds
                    raise RuntimeError('Unable to get port number used by '
                                       'simulator, does this simulator version '
                                       'not support automatic port selection?')

    def check(self) -> None:
        """Raises an exception if the simulator has unexpectedly shut down.

        Does nothing if the simulator is running or was shut down by calling
        :meth:`close` or exiting a 'with' block. If the simulator is otherwise
        not running, raises a :class:`.SimulatorTerminated` exception with
        information about why the simulator terminated extracted from
        :attr:`stdout` and :attr:`stderr`.

        """
        if not self._closed_normally and self._proc.poll() is not None:
            # To give a good error message, check stderr and stdout
            if self.stderr:
                # Usually an exception message
                # Remove backtrace if present
                err = self.stderr.partition('\nBacktrace:\n')[0]
                # Strip the part before the reason
                reason = err.partition(' thrown, terminating\nReason: ')[2]
                if reason:
                    err = reason
                raise SimulatorTerminated(err.strip())
            if self.stdout:
                # Look for thread crash message in stdout
                # This happens if the web thread crashes, as the simulator
                # keeps running in fallback mode if another thread crashes
                err = self.stdout.partition(
                    ' crashed with exception message: ')[2]
                if err:
                    err = err.partition('Shutting down...')[0]
                    raise SimulatorTerminated(err.strip())
                # Otherwise, just dump all of stdout
                raise SimulatorTerminated(
                    'Simulator terminated unexpectedly, stdout:\n' +
                    self.stdout)
            # Simulator isn't running but also didn't print anything
            raise SimulatorTerminated('Simulator terminated unexpectedly')

    def close(self) -> None:
        """Shuts down the simulator.

        Does not need to be called directly if a 'with' block is used. Raises a
        :class:`.SimulatorTerminated` exception if the simulator already shut
        down unexpectedly.

        """
        if hasattr(self, '_closed_normally') and not self._closed_normally:
            self.check()
            self._proc.terminate()
            self._proc.wait()
            self._closed_normally = True

    @property
    def port(self) -> int:
        """The port chosen by the simulator in automatic port selection mode.

        Returns None if automatic port selection was not enabled.
        """
        return self._port

    @property
    def stdout(self) -> str:
        """Returns all of the text printed to stdout since the start."""
        self._stdout += self._proc.stdout.read().decode('utf-8')
        return self._stdout

    @property
    def stderr(self) -> str:
        """Returns all of the text printed to stderr since the start."""
        self._stderr += self._proc.stderr.read().decode('utf-8')
        return self._stderr

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()

    def __del__(self):
        # Make sure to clean up when garbage collected or the interpreter exits
        self.close()
